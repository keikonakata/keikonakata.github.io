<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title> Keiko Nakata - A simple and efficient implementation for small databases</title>
  <link href="../css/default.css" type="text/css" rel="stylesheet" />
</head>
<body>
        <header>
            <nav>
                <a href="../index.html">Home</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <article>
    <section class="header">
        <h1>A simple and efficient implementation for small databases</h1>
        Updated on 2021-05-16
        
    </section>
    <section>
        <p>The paper presents a technique for implementing samll databases that frequently occor in operating systems and distributed systems design.</p>
<h2 id="the-problem">The problem</h2>
<p>We want to manage data that is structured and must persist across system restart.</p>
<p>The proposed solution is suitable for databases with the following characteristics:</p>
<ul>
<li><p>relatively small – up to about 10 megabytes</p></li>
<li><p>moderate rate of updates – a burst rate of up to 10 transactions per second, a long term rate of up to 1000 transactions per day</p></li>
<li><p>single-shot transaction (not a transaction composed of multiple client actions)</p></li>
</ul>
<p>The techniques based on</p>
<ul>
<li><p>a main memory database with checkpoints and a re-do log</p></li>
<li><p>high-level language data structure</p></li>
<li><p>RPCs</p></li>
<li><p>strongly typed access to the backing store</p></li>
</ul>
<h2 id="design">Design</h2>
<p>The database is represented as an ordinary data structure in virtual memory. Its counterpart on disk has two components:</p>
<ul>
<li><p>a checkpoint of some previous (consistent) state of the entire database, and</p></li>
<li><p>a log recording each subsequent update to the dataabse.</p></li>
</ul>
<p>A read access (to the database) consists purely of a lookup in the virtual memory.</p>
<p>An update is made in three steps, consisting of two virtual memory operations and one disk write:</p>
<ol type="1">
<li><p>The virtual memory data is read to verify any preconditions of the update, such as consistency invariants or access controls.</p></li>
<li><p>All the parameters of the update are gathered together and recorded as an entry in the disk log. This is the commit point.</p></li>
<li><p>The update is applied to the virtual memory data.</p></li>
</ol>
<p>The implementation must use an appropriate locking strategy to serialize updates and to prevent interference between updates and concurrent enquiries.</p>
<p>From time to time, the implementation</p>
<ol type="1">
<li><p>recordes on disk a checkpoint containing the entire contents of the virtual memory datastructure, then</p></li>
<li><p>resets the log to be empty, and</p></li>
<li><p>removes any previous checkpoint from the disk.</p></li>
</ol>
<p>The implementation can use the primitives of its host file system to ensure that these actions are performed atomically.</p>
<h3 id="example">Example</h3>
<p>Consider a simple name server, which offers a general purpose name-to-value mapping. It may use three locking modes to mediate concurrent access, shared, update and exclusive:</p>
<table>
<thead>
<tr class="header">
<th>&amp;</th>
<th style="text-align: center;">shared</th>
<th style="text-align: center;">update</th>
<th style="text-align: center;">exclusive</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>shared</strong></td>
<td style="text-align: center;">o</td>
<td style="text-align: center;">o</td>
<td style="text-align: center;">x</td>
</tr>
<tr class="even">
<td><strong>update</strong></td>
<td style="text-align: center;">o</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr class="odd">
<td><strong>exclusive</strong></td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
</tbody>
</table>
<ul>
<li><p>An enquiry is performed with a shared lock.</p></li>
<li><p>An update first acquires an update lock. After it has verified its preconditions, it assembles its log record and commits it to disk. Then the update lock is converted to an exclusive lock and modifies the virtual memory structures.</p></li>
<li><p>An update lock is held while writing a checkpoint.</p></li>
</ul>
<h4 id="references">References</h4>
<p><a href="https://dl.acm.org/doi/10.1145/41457.37517">A simple and efficient implementation of a small databases (SOSP ’87)</a></p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
